#!/usr/bin/env python

"""
m2g.graph
~~~~~~~~~~

Contains the primary functionality for connectome estimation after tractography has completed.
Used in the final stage of the pipeline.
"""


# standard library imports
import os
import time
import csv
from itertools import combinations
from functools import reduce
from collections import defaultdict
from pathlib import Path

# package imports
import numpy as np
import networkx as nx
import nibabel as nib
from dipy.tracking._utils import _mapping_to_voxel, _to_voxel_coordinates
from m2g.utils.gen_utils import timer
import matplotlib
from joblib import Parallel, delayed

matplotlib.use("agg")
from matplotlib import pyplot as plt
from graspologic.utils import ptr
from graspologic.plot import heatmap


class GraphTools:
    """Initializes the graph with nodes corresponding to the number of ROIS

    Parameters
    ----------
    rois : ndarray
        ROIs as array
    tracks : list
        Streamlines for analysis
    affine : ndarray
        a 2-D array with ones on the diagonal and zeros elsewhere (DOESN'T APPEAR TO BE Used)
    outdir : Path
        location of output directory
    connectome_path : str
        Path for the output connectome file (.csv file)
    attr : int, optional
        Path to atlas before registration. By default None
    sens : str, optional, DEPRACATED
        type of MRI scan being analyzed (can be 'dwi' or 'func'), by default "dwi"
    n_cpus : int, optional
        Number of cpus to use when computing the edges

    Raises
    ------
    ValueError
        graph saved with unsupported igraph modality
    ValueError
        graph saved not using edgelist, gpickle, or graphml
    """

    def __init__(
        self,
        rois,
        tracks,
        affine,
        outdir,
        connectome_path,
        attr=None,
        sens="dwi",
        n_cpus=1,
    ):

        self.edge_dict = defaultdict(int)
        # self.roi_file = rois
        # self.roi_img = nib.load(self.roi_file)
        self.rois = nib.load(rois)
        self.rois = self.rois.get_data().astype("int")
        # self.n_ids = self.rois[self.rois > 0]
        # self.N = len(self.n_ids)
        self.modal = sens
        self.tracks = tracks
        self.affine = affine
        self.outdir = outdir
        self.connectome_path = os.path.dirname(connectome_path)
        self.attr = attr
        self.n_cpus = int(n_cpus)

    @timer
    def make_graph_old(self):
        """
        Takes streamlines and produces a graph
        **Positional Arguments:**
                streamlines:
                    - Fiber streamlines either file or array in a dipy EuDX
                      or compatible format.
        """

        print("Building connectivity matrix...")
        self.g = nx.Graph(
            name="Generated by NeuroData's MRI Graphs (m2g)",
            date=time.asctime(time.localtime()),
            source="http://m2g.io",
            region="brain",
            sensor=self.modal,
            ecount=0,
            vcount=len(self.n_ids),
        )
        print(self.g.graph)

        [self.g.add_node(ids) for ids in self.n_ids]

        nlines = np.shape(self.tracks)[0]
        print("# of Streamlines: " + str(nlines))

        for idx, streamline in enumerate(self.tracks):
            if (idx % int(nlines * 0.05)) == 0:
                print(idx)

            points = np.round(streamline).astype(int)
            p = set()
            for point in points:
                try:
                    loc = self.rois[point[0], point[1], point[2]]
                except IndexError:
                    loc = ""

                if loc:
                    p.add(loc)

            edges = combinations(p, 2)
            for edge in edges:
                lst = tuple([int(node) for node in edge])
                self.edge_dict[tuple(sorted(lst))] += 1

        edge_list = [(k[0], k[1], v) for k, v in list(self.edge_dict.items())]
        self.g.add_weighted_edges_from(edge_list)
        return self.g, self.edge_dict

    @timer
    def make_graph(self, error_margin=2, overlap_thr=1, voxel_size=2):
        """Takes streamlines and produces a graph using Numpy functions

        Parameters
        ----------
        error_margin : int, optional
            Number of mm around roi's to use (i.e. if 2, then any voxel within 2 mm of roi is considered part of roi), by default 2
        overlap_thr : int, optional
            The amount of overlap between an roi and streamline to be considered a connection, by default 1
        voxel_size : int, optional
            Voxel size for roi/streamlines, by default 2

        Returns
        -------
        Graph
            networkx Graph object containing the connectome matrix
        """
        print("Building connectivity matrix...")

        # Instantiate empty networkX graph object & dictionary
        # Create voxel-affine mapping
        lin_T, offset = _mapping_to_voxel(
            np.eye(4)
        )  # TODO : voxel_size was removed in dipy 1.0.0, make sure that didn't break anything when voxel size is not 2mm

        self.attr = nib.load(self.attr)
        self.attr = self.attr.get_data().astype("int")

        mx = len(np.unique(self.attr.astype(np.int64)))
        # node_dict = dict(
        #    zip(np.unique(self.rois).astype("int16") + 1, np.arange(mx) + 1)
        # )
        node_dict = dict(zip(np.unique(self.attr).astype("int16"), np.arange(mx)))

        lost_rois = []
        # Track lost rois
        for un in np.unique(self.attr.astype(np.int64)):
            if un not in self.rois:
                lost_rois.append(un)

        if len(lost_rois) > 0:
            with open(f"{self.connectome_path}/lost_roi.csv", mode="w") as lost_file:
                lost_writer = csv.writer(lost_file, delimiter=",")
                lost_writer.writerow(lost_rois)

        nlines = len(self.tracks)
        print("# of Streamlines: " + str(nlines))

        def worker(tracks):
            g = nx.Graph(ecount=0, vcount=mx)
            # Add empty vertices
            nodelist = list(range(0, mx))
            for node in nodelist:  # (1, mx + 1):
                g.add_node(node)

            edge_dict = defaultdict(int)
            for s in tracks:
                # Map the streamlines coordinates to voxel coordinates and get labels for label_volume
                # i, j, k = np.vstack(np.array([get_sphere(coord, error_margin,
                #                                          (voxel_size, voxel_size, voxel_size),
                #                                          self.roi_img.shape) for coord in
                #                               _to_voxel_coordinates(s, lin_T, offset)])).T

                # Map the streamlines coordinates to voxel coordinates
                points = _to_voxel_coordinates(s, lin_T, offset)

                # get labels for label_volume
                i, j, k = points.T

                lab_arr = self.rois[i, j, k]
                endlabels = []
                for lab in np.unique(lab_arr).astype("int16"):
                    if (lab > 0) and (np.sum(lab_arr == lab) >= overlap_thr):
                        endlabels.append(node_dict[lab])
                endlabels = sorted(endlabels)

                edges = combinations(endlabels, 2)
                for edge in edges:
                    edge_dict[edge] += 1

            edge_list = [(k[0], k[1], v) for k, v in edge_dict.items()]
            g.add_weighted_edges_from(edge_list)
            A = nx.to_numpy_array(g, nodelist=nodelist)
            return A

        res = Parallel(n_jobs=self.n_cpus)(
            delayed(worker)(self.tracks[start :: self.n_cpus])
            for start in range(self.n_cpus)
        )
        conn_matrix = reduce(np.add, res)

        # These steps are not needed.
        # conn_matrix = np.array(nx.to_numpy_matrix(self.g))
        # conn_matrix[np.isnan(conn_matrix)] = 0
        # conn_matrix[np.isinf(conn_matrix)] = 0
        # conn_matrix = np.asmatrix(np.maximum(conn_matrix, conn_matrix.transpose()))
        g = nx.from_numpy_matrix(conn_matrix)

        return g

    def save_graph(self, graphname, fmt="igraph"):
        """Saves the graph to disk

        Parameters
        ----------
        graphname : str
            Filename for the graph
        fmt : str, optional
            Format you want the graph saved as [edgelist, gpickle, graphml, txt, npy, igraph], by default "igraph"

        Raises
        ------
        ValueError
            Unsupported modality (not dwi or func) for saving the graph in igraph format
        ValueError
            Unsupported format
        """

        self.g.graph["ecount"] = nx.number_of_edges(self.g)
        self.g = nx.convert_node_labels_to_integers(self.g, first_label=0)
        print(self.g.graph)
        if fmt == "edgelist":
            nx.write_weighted_edgelist(self.g, graphname, encoding="utf-8")
        elif fmt == "gpickle":
            nx.write_gpickle(self.g, graphname)
        elif fmt == "graphml":
            nx.write_graphml(self.g, graphname)
        elif fmt == "txt":
            np.savetxt(graphname, nx.to_numpy_matrix(self.g))
        elif fmt == "npy":
            np.save(graphname, nx.to_numpy_matrix(self.g))
        elif fmt == "igraph":
            nx.write_weighted_edgelist(
                self.g, graphname, delimiter=" ", encoding="utf-8"
            )
        else:
            raise ValueError(
                "Only edgelist, gpickle, graphml, txt, and npy are currently supported"
            )

        if not os.path.isfile(graphname):
            raise FileNotFoundError(f"File {graphname} not created.")

        print(f"Graph saved. Output location here: {graphname}")

    def save_graph_png(self, qa_dir, graphname):
        """Saves adjacency graph, made using graspy's heatmap function, as a png. This will be saved in the qa/graphs_plotting/ directory

        Parameters
        ----------
        graphname : str
            name of the generated graph (do not include '.png')
        """

        conn_matrix = np.array(nx.to_numpy_matrix(self.g))
        conn_matrix = ptr.pass_to_ranks(conn_matrix)
        heatmap(conn_matrix)
        outpath = str(qa_dir / f"{Path(graphname).stem}.png")
        plt.savefig(outpath)
        plt.close()

    def summary(self):
        """
        User friendly wrapping and display of graph properties
        """
        print("\nGraph Summary:")
        print(nx.info(self.g))
